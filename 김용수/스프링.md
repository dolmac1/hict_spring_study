# <04. 스프링 입문>

## 01. 객체지향 - 01. 개발 환경 설치
- jdk 설치(오라클 계정 필요) - 현재 기준 jdk 11 설치(자바는 3단위로 버전이 올라가는데 14버전은 아직 잘 사용하지 않음)
- java -version 으로 버전 확인
- 인텔리제이 설치(이클립스 같은 다른 툴들도 사용할 수 있지만 이클립스보다 지원하는 것들이 더 많음(단, 지원하는 것이 많은 만큼 유료임 - 30일동안은 무료 사용 가능))
- (개인용 인텔리제이는 한달에 14.9달러정도)
- 인텔리제이 실행
- New Project - Spring Initializr - Gradle - Java - Next - Spring Web - Finish
- Gradle 버전 설치될 때까지 대기(한번만 설치하면 다음부터는 자동으로 실행됨)
- DemoApplication을 빌드 후 실행하여 정상 동작할 경우 실습할 환경이 구성 완료된 것

※ (툴이 안드로이드 스튜디오랑 비슷한 것 같음(느낌상))

## 01. 객체지향 - 02. 객체지향이란
- 객체 지향의 개념은 50년 넘은 역사를 가지고 잇음
- 객체 지향 전에는 절차지향의 언어 형태가 주를 이뤘음(ex. C언어)
- 간단한 로직을 처리하는데는 절차지향이 나쁘지 않았으나 복잡도가 증가하면서 유지보수, 개발 기간 면에서 비효율 발생
- 이러한 비효율을 해결하기 위해서 객체지향 프로그래밍이 도입됨
- 객체지향의 특성 : 추상화, 상속, 은닉, 재사용, 인터페이스 등
- 객체 지향은 사물을 그대로 모델링하여 이들의 행위, 속성을 정의하고 실제 사물이 동작하는 방식으로 설계
- 사물을 객체(Object), 행위를 Method, 변수를 Variable이라고 정의
- 실제 사물을 중심으로 개발하기 때문에 기존의 절차지향보다 편리한 설계 가능
- java는 1995년에 C++과 비슷한 구문을 채택하여 개발, 하지만 C++이 가지고 있는 시스템 레벨 접근, 메모리 직접할당 해제, 포인터 등의 개발 방식을 사용하지않음
- 자바 가상머신 JVM만 있으면 어디든지 호환되는 장점을 가지고 있음
- 객체 == 사물 == Object이기 때문에 각 객체가 가지고 있는 속성, 동작 등을 가지고 있도록 Class의 형태로 정의해줌
- 객체의 3가지 요소
  - 상태 유지 - 객체는 상태 정보를 저장하고 유지되어야함, 변수로 정의 되어져 변경될 수 있어야함
  - 기능 제공 - 제공되는 메소드를 통해서 접근할 수 있도록 해야함
  - 고유 식별자 제공 - 각각의 객체는 고유한 식별자를 가져야함
- 물리 객체와 개념 객체
  - 물리객체는 실제로 사물이 존재하며 이를 클래스로 정의한 객체를 의미함(ex. 자동차 렌탈 시스템 : 자동차, 직원 등)
  - 개념객체는 service에 해당되며 비지니스 로직을 처리하는 부분을 의미, 여러 객체를 서로 상호작용 하도록 하며, 객체가 제공하는 오퍼레이션을 통해 객체의 속성을 변경할 수 있도록 함(비밀번호 초기화, 재등록 처리 등)

## 01. 객체지향 - 03. 객체지향 4가지 핵심요소
- 객체 지향의 4대 특성이 존재함
- 캡슐화
  - 캡슐화는 객체의 속성을 보호하기 위해서 사용
  - 제공하는 메소드를 통해서 속성의 상태를 변경함
  - 속성이 선언되어있으나 이의 상태를 변경하는 method가 없다면 잘못된 속성임, 무조건 있어야한다
  - 실물 객체가 가진 기능을 모두 제공해주어야함
  - 각각의 method는 서로 관련성이 있어야함(각각의 속성의 상대되는 기능을 제공해야함)
  - 각각의 객체안의 method는 객체 안의 속성을 처리해야하며, 남의 객체에 정의된 속성을 변경하면 안됨
  - getter / setter를 통해서 외부에서 내부 속성을 직접 접근하는 것이 아닌 간접적으로 접근
  - crud method : 데이터 처리를 위한 crud 제공
  - 비지니스 로직 처리를 위한 method 제공
  - 객체의 생명 주기 처리하는 메소드 제공
  - 객체의 영구성 관리하는 메소드 제공(영구적인 속성은 외부에서 접근할 수 없도록 private로 선언해주어야함)
  - 장점은 추상화 제공, 재 사용성 , 응집도 증가(캡슐화 형태로 제공되어 자기 자신의 내부의 정보만 변경), 유지보수의 효율성 증가가 있음, 무결성 보장(변수는 private, 메소드는 public 형태로 선언)
- 상속
  - 객체 지향에서의 상속은 속성의 상속이 아닌, 하위로 갈수록 구체화 되는 것(유닛 -> 지상 유닛 -> 질럿)
  - 상속의 효과는 프로그램 구조에 대한 이해도 증가(상속 받은 객체들은 부모객체에 있는 속성을 물려받기 때문에 상위 클래스를 보고 하위 클래스의 동작을 이해할 수 있음)
  - 재사용성 향상(상속을 하면 내용을 모두 정의하지 않고 상속받아서 사용할 수 있음)
  - 확장성 향상(일관된 정보로 확장할 수 있음)
- 다형성
  - 각자의 객체를 다형성으 생성할 수 있으며 이를 통해서 같은 동작을 다양하게 정의할 수 있음
- 추상화
  - 객체지향에서 추상화는 모델링임
  - 구체적으로 공통적인 부분, 특정 특성을 분리해서 재조합하는 부분임
  - 다형성, 상속 모두 추상화에 포함되는 내용임

## 01. 객체지향 - 04. 객체지향 설계 5원칙
- 객체 지향 설계 5원칙은 SOLID라고 부름
- 응집도와 결합도
  - 좋은 소프트웨어를 만들기 위해서는 결합도는 낮추고 응집도를 높여야함
    - 결합도는 모듈간 상호 의존 정도를 나타내는 지표
    - 응집도는 하나의 모듈 내부에 존재하는 구성 요소들의 기능적 관련성
- 5대원칙
  - 단일 책임의 원칙(SRP)
    - 어떠한 클래스를 변경해야 하는 이유는 한가지 뿐이어야함
    - 다른 모듈들이 추가가 되더라도 다른곳을 수정하지 않아도 되어야함
    - 각각의 객체를 상속받아서 사용하여 각자의 기능만 바꾸도록 설계를 해야함
  - 개방 폐쇄 원칙
    - 자신의 확장에는 열려 있고, 주변의 변화에 대해서는 닫혀 있어야함
    - JDBC가 가장 표준이 되는 예시임(JDBC 하나가 어플과 1대1로 닫아두고, 각각의 SQL에는 확장성있게 연결됨)
  - 리스코프 치환 원칙
    - 서브 타입은 언제나 자신의 기반 타입으로 교체할 수 있어야함
  - 인터페이스 분리 원칙
    - 클라이언트는 자신이 사용하지 않는 메서드에 의존 관계를 맺으면 안됨
    - 자신이 사용하지 않는 부분에 대해서는 상속받지 말고 인터페이스를 분리해서 사용
  - 의존 역전 원칙
    - 자신보다 변하기 쉬운 것에 의존하지 말아야함

## 01. 객체지향 - 05. POJO JAVA
- POJO 자바는 순수한 자바 오브젝트를 뜻함
- 예전에는 EJB를 많이 사용하여 외부에 대한 종속성이 높아서 교체, 유지보수에 비용이 많이 필요했음
- POJO 특징
  - 특정 규약에 종속되지 않음(특정 라이브러리나 모듈에서 정의된 클래스를 상속 받아서 구현하지 않아도 됨)
  - 특정 환경에 종속되지 않음(비즈니스 로직을 처리하는 부분이 외부 종속적이면 안됨)
- POJO Framework 에는 Spring, Hibernate 등이 있음
  - 위의 두 프레임워크는 객체 지향적인 설계를 가지고 있으며 POJO를 지향함

## 02. 디자인 패턴 - 01. 디자인패턴이란
- 디자인 패턴이란 자주 사용하는 설계 패턴을 정형화 해서 이를 유형별로 가장 최적의 방법을 개발 할 수 있도록 정해둔 설계
- 알고리즘과 비슷한데 명확한 답이 있는 것은 아님
- Gof 디자인 패턴
  - 객체 지향 개념에 따른 설계 중 재사용할 경우 유용한 설계를 디자인 패턴으로 미리 정리 해둔 것
  - Gof의 디자인 패턴은 총 23개이며 이를 잘 이용하면 경험이 부족해도 좋은 소프트웨어 설계 가능
- 디자인 패턴의 장점
  - 개발자간 원활한 소통
  - 소프트웨어 구조 파악 용이
  - 재사용을 통한 개발시간 단축
  - 설계 변경 요청에 대한 유연한 대처
- 디자인 패턴의 단점
  - 객체지향적인 설계 / 구현을 해야해서 이해가 필요
  - 초기 투자 비용 부담
- 생성 패턴
  - 객체를 생성하는 것과 관련된 패턴, 시스템이 미치는 영향을 최소화, 코드의 유연성을 높여줌
  - factory method, singleton, prototype 등이 있음
- 구조 패턴
  - 프로그램 내의 자료구조나 인터페이스 구조 등의 구조를 설계하는데 활용 될 수 있는 패턴
  - 큰 규모의 시스템에서는 많은 클래스들이 서로 의존성을 가지게 되는데 이런 복잡한 구조를 개발하기 쉽게 해줌
  - adapter, composite, bridge, decorator, facade, proxy 등이 있음
- 행위 패턴
  - 반복적으로 사용되는 객체들의 상호작용을 패턴화한 것
  - iterator, observer, strategy 등이 있음

## 02. 디자인 패턴 - 02. 싱글톤 패턴
- 싱글톤 패턴은 어떤 객체가 유일하게 1개만 존재할 때 사용
- 주로 서로 자원을 공유할 때 사용, TCP Socket 통신에서 서버와 연결된 connect 객체에 주로 사용
- 패키지는 java 프로젝트 생성 후 프로젝트 우클릭 - New - package를 통해서 생성
- 해당 패키지에 java class를 생성해서 패턴 생성
- 싱글톤 방식 개발 예제 : singleton 폴더
- 싱글톤 방식이 아닌 public으로 객체를 선언하여 new를 사용할 경우에는 두 객체가 다르다는 결과가 나옴

## 02. 디자인 패턴 - 03. 어댑터 패턴
- 어댑터 패턴의 경우에는 실생활에서 100v를 220v를 변경해주는 것과 같은 것으로 기존 클래스의 인터페이스를 변환하여 재사용할 수 있도록 해주는 것
- 인터페이스 오버라이딩 해줄 때에는 class 뒤에 implements를 붙여주고 에러나면 alt enter 눌러서 처리해주면 됨
- 어댑터를 통해서 다른 인터페이스에 있는 형태가 맞지 않는 함수를 사용할 수 있음
- 어댑터 패턴 예제 : adapter 폴더

## 02. 디자인 패턴 - 04. 프록시 패턴
- 프록시는 대리인이란 뜻으로 뭔가를 대신 처리할 때 사용하는 디자인 패턴
- 

## 03. 웹 개발 개론 - 01. 웹 개발이란
- www는 인터넷에 연결된 컴퓨터를 통해 사람들이 정보를 공유할 수 있는 전 세계적인 정보 공간
- 웹을 구성하는 3가지 요소 : URI, HTTP, HTML
  - URI는 모든 정보에 접근할 수 있는 정보
  - HTTP는 어플리케이션을 컨트롤 할 때 사용하는 프로토콜
  - HTML은 XML을 바탕으로 한 범용 문서 포맷
 
## 03. 웹 개발 개론 - 02. REST API
- Representational State Transfer : 자원의 상태 전달 이라는  네트워크 아키텍처
- client와 server 과 서로 독립적으로 분리되어있어야함
- stateless : 요청에 대해서 클라이언트의 상태를 서버에 저장하지 않음
- cache : 클라이언트는 서버의 응답을 cache할 수 있어야 한다. 클라이언트가 캐시를 통해서 응답을 재사용하므로서 서버의 부하를 낮춤
- 계층화 : 서버와 클라이언트 사이에 방화벽, 게이트웽, 프록시 등 다양한 계청 형태로 구성이 가능하여야함
- 인터페이스 일관성 : 인터페이스를 일관성을 지키고, 아키텍처를 단순화시켜 작은 단위로 분리하여 독립적으로 개선 될 수 있어야함
- Code on Demand : 특정 기능을 서버로 부터 클라이언트가 전달받아 코들르 실행 할 수 있어야함
- 인터페이스의 일관성
  - 자원의 식별
    - 웹 기반의 REST에서는 리소스 접근을 할 때 URI를 사용(ex. https://a.co.kr/user/100  - 리소스 : user 식별자 : 100)
  - 메시지를 통한 리소스 조작
    - 웹에서는 다양한 방식으로 데이터를 전달 할 수 있음
    - 그중에서 html, json 등을 가장 많이 사용
    - header에 content-type을 지정하여 어떤 데이터 타입인지 지정해 줄 수 있음
    - 리소스 조작을 위해서 데이터 전체를 전달하는 것이 아닌 메시지로 전달
      - 이걸 지키지 않을 경우에는 이름이 바뀌면 에러가 발생할 수 있음
  - 자기 서술적 메시지
    - 요청하는 데이터가 어떻게 처리 되어야 하는지 충분한 데이터를 포함(GET, POST, PUT, DELETE)
  - 어플리케이션 상태에 대한 엔진으로써 하이퍼미디어
    - REST API를 개발할 때 단순히 Client요청에 대한 데이터만 응답 해주는 것이 아닌 관련된 리소스 정보 link까지 포함(이부분은 현업에서 잘 사욛되진 않음)

## 03. 웹 개발 개론 - 03. URI 설계 패턴
- URI는 인터넷에서 특정 자원을 나타내는 주소값으로 해당 값은 유일함
- URL은 인터넷 상에서의 자원, 특정 파일이 있는 위치를 식별하는 주소
- URI 설계원칙(RFC-3986)
  - 슬래시 구분자(/)는 계층 관계를 나타내는데 사용
  - URI의 마지막 문자로는 /를 포함하지 않음
  - 하이픈(-)는 가독성을 높일 때 사용
  - 밑줄(_)는 사용하지 않는다
  - URI경로에는 소문자가 적합
  - 파일 확장자는 URI에 포함하지 않는다.
  - 프로그래밍 언어에 의존적인 확장자를 사용하지 않음
  - 구현에 의존적인 경로를 사용하지 않는다(- 특정 부분을 외부에 유출하면 보안에 취약할 수 있어서)
  - 세선 ID를 URI에 포함하지 않음
  - 프로그래밍 언어의 Method명을 이용하지 않음
  - 명사의 단수형보다 복수형 사용
  - 컨트롤러 이름은 동사나 동사구를 사용
  - 경로 부분 중 변하는 부분은 유일한 값으로 대체(ex. /a/b/lessons/{lesson-id}/users/{user-id} -> /a/b/lesson/2/users/100)
  - CRUD 기능을 나타내는 것은 URI에 사용하지 않음
  - URI Query Parameter 디자인(URI의 쿼리 부분으로 컬렉션 결과에 대해서 필터링 할 수 있음(/lessons?chaper=2))
  - URI 쿼리는 컬렌션의 결과를 페이지로 구분하여 나타내는 데 사용(/web?chapter=2&page=0&size=10)
  - API에 있어서 서브 도메인은 일관성 있게 사용(api.aaa.co.kr이런식으로)
  - 클라이언트 개발자 포탈 서브 도메인은 일관성있게 (앞에 dev를 붙여준다거나 해서(dev.aaa.co.kr))

## 03. 웹 개발 개론 - 04. HTTP Protocol
- HTTP는 RFC 2616에서 규정한 Web에서 데이털르 주고 받는 프로토콜
- 다양한 컴퓨터에서 다루는 파일들을 주고받을 수 있음
- 반드시 메시지를 주고(Request) 응답을 받는(Response) 형태의 통신 방법 사용
- 응답을 반드시 받아야하기 때문에 timeout을 설정하여 일정시간 동안 응답을 받지 못하면 취소하도록 해야함
- HTTP의 요청 메소드는 8가지가 있음
- GET(리소스 취득)
  - CRUD : R
  - 멱등성 : O(몇번을 요청해도 같은 응답이 오는가)
  - 안정성 : O
  - Path Variable : O
  - Query Parameter : O
  - DataBody : X
- POST(리소스 생성, 추가)
  - CRUD : C
  - 멱등성 : X(몇번을 요청해도 같은 응답이 오는가)
  - 안정성 : X
  - Path Variable : O
  - Query Parameter : △
  - DataBody : O
- PUT(리소스 갱신, 생성)
  - CRUD : C,U
  - 멱등성 : O(몇번을 요청해도 같은 응답이 오는가)
  - 안정성 : X
  - Path Variable : O
  - Query Parameter : O
  - DataBody : O
- DELETE(리소스 삭제)
  - CRUD : D
  - 멱등성 : O(몇번을 요청해도 같은 응답이 오는가)
  - 안정성 : X
  - Path Variable : O
  - Query Parameter : △
  - DataBody : X
- HEAD(헤더 데이터 취득)
  - 멱등성 : O(몇번을 요청해도 같은 응답이 오는가)
  - 안정성 : O
- OPTIONS(지원하는 메소드 취득)
  - 멱등성 : O(몇번을 요청해도 같은 응답이 오는가)
- CONNECT(프록시 동작의 터널 접속으로 변경)
  - 멱등성 : X(몇번을 요청해도 같은 응답이 오는가)
- DELETE, HEAD, OPTIONS, CONNECT는 자주 사용하지 않음
- HTTP Status Code는 응답의 상태를 나타내는 코드
  - 100번대 : 처리중
  - 200번대 : 성공
  - 300번대 : 리다이렉트(새로운 주소로 다시 요청해라)
  - 400번대 : 클라이언트 에러
  - 500번대 : 서버 에러
- 자주 사용하는 코드
  - 200 성공
  - 201 성공, 리소스 생성 성공
  - 301 리다이렉트, 리소스가 다른 장소로 변경됨
  - 303 리다이렉트, client에서 자동으로 새로운 리소스로 요청 처리
  - 400 요청오류, 파라미터 에러
  - 401 권한없음
  - 404 리소스 없음
  - 500 서버 내부 에러
  - 503 서비스 정지

## 04. 스프링 부트 시작하기 - 01. 스프링 부트란
- 스프링 부트는 단순하게 실행되며, 프로덕션 제품 수준의 스프링 기반 어플리케이션을 쉽게 만들 수 있음
- 스프링 부트 어플리케이션에는 스프링 구성이 거의 필요 없음
- 스프링 부트 java -jar로 실행하는 자바 어플리케이션을 만들 수 있음
- 스프링 부트의 주요 목표
  - 스프링 개발에 대해서 빠르고, 광범위하게 적용 가능
  - 기본값 설정이 잘 되어있음
  - 대규모 프로젝트에 공통적인 비 기능 제공
  - xml 구성 요구사항이 없음
- 빌드 툴은 maven과 gradle이 있음
- servlet 은 톰캣으로 실습 할 것임
- 스프링에 비해서 불편한 설정이 많이 없어졌음

## 04. 스프링 부트 시작하기 - 02. Hello World API를 만들어보자
- REST 클라이언트를 설치해야함(크롬 웹스토어에서 talend api tester를 크롬에 추가해주면됨)
- 설치한 클라이언트를 실행해줌
- 개발은 인텔리제이를 통해서 해야함
- 포트같은 서버의 정보를 바꾸려면 resources의 application.properties를 변경해주면 됨
- REST API를 처리해주려면 Controller를 선언해주어야함
- @RestController를 선언하여 reslt api를 처리하는 컨트롤러라는 것을 알려야함
- @RequestMapping("/api경로")를 통해서 URI를 지정해주어야함
- 메소드 직전에는 매핑 정보를 입력해주어야하는데 GET의 경우에는 @GetMapping("/api명")이런식으로 써서 해당 경로의 어떤 api를 호출하면 이 함수가 호출되는지 지정해주어야함
- get1번에 hello spring boot라는 화면을 띄워주는 GET 방식의 REST API 프로그램 예시

## 04. 스프링 부트 시작하기 - 03. GET API
- GET의 의미는 리소스의 취득으로 Path Variable과 Query Parameter를 가질 수 있음
- 이 때 변화하는 값이 들어갈 때에는 @GetMapping에 {이름} 이런식으로 선언해주어야하며 함수에는 @PathVariable을 통해 선언하여 가져다 쓸 수 있음
- 쿼리 파라미터도 받아와서 사용해줄 수 있음(시작은 ?로 시작하며 구분은 &로 구분해줌)
- 이때 매핑은 @RequestParam을 통해서 어떤 방식으로 맵핑해줄 것인가를 지정해주어야함
- 맵핑을 이용해서 어떤 변수만 받아주고 싶은지 지정도 해줄 수 있음
- private 객체를 만들어서 활용하는 방법이 가장 많이 사용됨
- get1번에 GetApiController 자바 클래스 참조
 

